In User model, two properties, 'max_score' and 'games_completed' are added in order to calculate the performance when ranking Users. The Users achieve higher max_score could rank higher. If max scores are same, then the less games_completed, the better User performed. 

In Game model, four properties, 'dice',  'score_card',  'cat_history' and 'dice_history' are added. 'Dice’ is a list of Integers to keep the dice result, if Users want to retrieve games and continue to play, 'dice' always keeps the latest dice result the User rolled in this game. 'Score_card' is to record the points User got in each category, so it also records the progress of the game. Unless all the categories have been chosen and recorded points, the game doesn't reach the end.  ‘Cat_history’ and ‘dice_history’ are both lists of Integers, which sequentially record the chosen categories and dice results respectively, and thus compose the game history. Since the dice result would be reset each round, and even you get same dice result, you can still choose different category as long as it has not been chosen in current game. So the pairs of dice results with corresponding chosen categories of each game may have value for User to review. To make the dice result and the category as a pair, I have added a class of GameHistory and a method to_hitory_form() in Game class.

The hard part to achieve in this game design is the game playing logic, because it involves two part, the dice and the category, and how many points you can get not only depends on the dice combination you rolled, but also the category you choose each time. So the key method in this game logic is to find and calculate the right score, with two arguments, the dice result and the category. The score-calculations of categories can be briefly divided into two types, one is counting the certain number of dice and getting points based on the count, and the other one is to check if the five dice match the specific pattern then getting fixed points. I used an additional list to store and count each number (from one to six) the dice have, because it can be easily used for both types of calculation. The category pattern can be easily represented by a ‘count list’ (using string to represent). The tricky part is to convert dice count list to string and to check if it has substring matches the pattern string. Besides, the categories are stored as EnumProperty, which is much convenient for later usage.

When designing cancel_game endpoint method, I chose to delete the entity but not adding a Boolean field to the model. I think the Boolean field to mark the game has been cancelled is meaningless, unless you can reactive the game, which is meaningless either. It is easy to remove the game from database using game.key.delete(), but user cannot reactive the game once cancelled in this way.
